
* compile
  need to add
  : -lpthread
  when compile.

* concept
  join
  detach

* pthread
** pthread_cancel
   defer it until it reaches a cancellation point. \\
   cause dead lock/memory leak if cancel unsafely!
   
   : pthread_testcancel()
   : boost::this_thread::interruption_point()
   
polling ?

* boost
  use exception
  it'll call destructor automatically

* async & future
  #+BEGIN_SRC C++
  #include "future"
  int func();
  // try start func() asynchronously in the background (now or later or never)
  // assign the result to the object of class std::future
  std::future<int> result(std::async(func());
  // ^ auto works as well
  // do something else
  result.get();
  #+END_SRC
  use future for two reasons:
  - it allows access to the "future" outcome *(store state/result)* of
    the functionality passed to async(). The outcome might be either a
    return value or an exception.
    : std::future<void> for returns nothing
  - async() may not start ever (if no more separated thread is
    availble, it will defer), use future to force a start.

  To have better effect, maximize the distance between calling
  async() and calling get()
  
** launch policy
   To force async() to not defer the passed functionality, explicitly
   passing a /launch policy/.
   #+BEGIN_SRC C++
   // force func() to start asynchronously now or throw std::system_error
   // if it's not possible to call here
   std::future<long> result = std::async(std::launch::async, func);
   // std::launch::defered
   #+END_SRC
   In this case, no need to call get() anymore. If the *lifetime* of
   the returned future ends, the program will *wait* for func() to
   finish.

** deal with exceptions
   If exception is not caught in the thread, future will keep this
   state until get() is called, and propagated to main.

** waiting and polling
   You can can *only call get() once*. After get(), the future is in an
   invalid state, which can be checke only by calling valid() for the
   future.

   Below are callable more than once
*** wait()
    wait() forces the start of a thread a future represents and *waits*
    (block) for the termination.
    Looks like get(), but can be called more than once, and don't
    return result. Call get() after wait().
*** wait_for(), wait_until()
    do /not/ force the thread to get started if it hasn't started yet.
    #+BEGIN_SRC CPP
    std::future<...> f(std::async(func));
    ...
    f.wait_for(std::chrono::seconds(10));
    f.wait_until(std::system_clock()::now() + std::chrono::minutes(1));
    #+END_SRC
    wait_for, wait_until return one of the following:
    | std::future_status::deferred | if async() deferred the operation and no calls to wait() or get() have yet forced it to start(both function return immediately in this case) |
    | std::future_status::timeout  | the waiting expired due to the passing timeout                                                                                               |
    | std::future_status::ready    | the operation is finished                                                                                                                    |
    
** shared future
   future's get() can only be called once. With situation when
   multiple threads process the outcome, use shared_future. Here,
   multiple get() calls are possible and *yield the same result or
   throw the same exception*.
   : std::shared_future<int> f = std::async(func);
   : auto f = std::async(func).share();
   | future                   | shared_future                    |
   |--------------------------+----------------------------------|
   | T future<T>::get()       | const T& shared_future<T>::get() |
   | T& future<T&>::get()     | T& shared_future<T&>::get()      |
   | void future<void>::get() | void shared_future<void>::get()  |
   "The *single-use* value get() is *move optimized*, the *const reference*
   get() is *access optimized*."

* note
** two situations may lead to one thread occupying cpu
  - std::future_status::deferred
    #+BEGIN_SRC CPP
    // need to judge, otherwise, the while loop may run forever!
    // or use std::launch::async when constructing 
    // if (f.wait_for(std::chrono::seconds(0)) != std::futrue_status::deferred))
    while (f.wait_for(std::chrono::seconds(0)) != std::future_status::ready) {
      // wait
    }
    #+END_SRC
  - yield
    hint to reschedule to the next thread
** lifetime
   - when parsing reference to thread, make sure the object's lifetime
   is larger than the thread
   - detach thread will go on runing even main exit? Make sure
     global/static object not destruct if they are use in detached thread.
   
  
