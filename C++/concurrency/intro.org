
* compile
  need to add
  : -lpthread
  when compile.

* concept
  join
  detach

* pthread
** pthread_cancel
   defer it until it reaches a cancellation point. \\
   cause dead lock/memory leak if cancel unsafely!
   
   : pthread_testcancel()
   : boost::this_thread::interruption_point()
   
polling ?

* boost
  use exception
  it'll call destructor automatically

* async & future
  #+BEGIN_SRC C++
  #include "future"
  int func();
  // try start func() asynchronously in the background (now or later or never)
  // assign the result to the object of class std::future
  std::future<int> result(std::async(func());
  // ^ auto works as well
  // do something else
  result.get();
  #+END_SRC
  use future for two reasons:
  - it allows access to the "future" outcome *(store state/result)* of
    the functionality passed to async(). The outcome might be either a
    return value or an exception.
    : std::future<void> for returns nothing
  - async() may not start ever (if no more separated thread is
    availble, it will defer), use future to force a start.

  To have better effect, maximize the distance between calling
  async() and calling get()
  
** launch policy
   To force async() to not defer the passed functionality, explicitly
   passing a /launch policy/.
   #+BEGIN_SRC C++
   // force func() to start asynchronously now or throw std::system_error
   // if it's not possible to call here
   std::future<long> result = std::async(std::launch::async, func);
   // std::launch::defered
   #+END_SRC
   In this case, no need to call get() anymore. If the *lifetime* of
   the returned future ends, the program will *wait* for func() to
   finish.

** deal with exceptions
   If exception is not caught in the thread, future will keep this
   state until get() is called, and propagated to main.

** waiting and polling
   You can can *only call get() once*. After get(), the future is in an
   invalid state, which can be checke only by calling valid() for the
   future.

   Below are callable more than once
*** wait()
    wait() forces the start of a thread a future represents and *waits*
    (block) for the termination.
    Looks like get(), but can be called more than once, and don't
    return result. Call get() after wait().
*** wait_for(), wait_until()
    do /not/ force the thread to get started if it hasn't started yet.
    #+BEGIN_SRC CPP
    std::future<...> f(std::async(func));
    ...
    f.wait_for(std::chrono::seconds(10));
    f.wait_until(std::system_clock()::now() + std::chrono::minutes(1));
    #+END_SRC
    wait_for, wait_until return one of the following:
    | std::future_status::deferred | if async() deferred the operation and no calls to wait() or get() have yet forced it to start(both function return immediately in this case) |
    | std::future_status::timeout  | the waiting expired due to the passing timeout                                                                                               |
    | std::future_status::ready    | the operation is finished                                                                                                                    |
    
** shared future
   future's get() can only be called once. With situation when
   multiple threads process the outcome, use shared_future. Here,
   multiple get() calls are possible and *yield the same result or
   throw the same exception*.
   : std::shared_future<int> f = std::async(func);
   : auto f = std::async(func).share();
   | future                   | shared_future                    |
   |--------------------------+----------------------------------|
   | T future<T>::get()       | const T& shared_future<T>::get() |
   | T& future<T&>::get()     | T& shared_future<T&>::get()      |
   | void future<void>::get() | void shared_future<void>::get()  |
   "The *single-use* value get() is *move optimized*, the *const reference*
   get() is *access optimized*."
   The multiple shared future objects share the same /shared
   state/. Though possible, it's risky to share one future object (by
   reference).

* thread
  As for async(), you can pass anything that's a /callable object/
  (function, member function, function object, lambda) together with
  possible additional arguments. It's recommended to pass all objects
  by value so that the thread uses only /local copies/.

  Thread is low-level interface, things it does not provides compared
  to async():
  - doesn't have a launch policy. Thread *always tries to start* the
    passed functionality in a new thread. If it isn't possible, it
    throws a std::system_error with the error code
    resource_unavailble_try_again.
  - *no interfaces to process the result or outcome of the thread*. The
    only thing you can get is a unique thread ID.
  - if an exception occurs that is not caught inside the thread, the
    program immediately aborts, calling std::terminate(). (won't
    propagate the exception to the caller?) \\
    : exception_ptrs ?
  - need to call join()(wait for teh end), detach()(let it run in the
    background without any control). If you don't do this before the
    lifetime of the thread objects ends or a move assignment to it
    happens, the program aborts, calling std::terminate()
  - if you let the thread run in the background and main() ends (return
    or exit), all threads are terminated abruptly.
    #+BEGIN_QUOTE
    To allow other threads to continue execution, the main thread
    should terminate by calling pthread_exit() rather than exit(3).
    #+END_QUOTE


    #+BEGIN_SRC C++
    #+END_SRC
  - Thread IDs
    Thread id of a joinable thread (thread with associated task) are
    unique. For those without associated task, its id is same as
    std::thread::id() (unique as well).
    : std::thread t;
    : assert(t.get_id() == std::thread::id());
    Note! For those nojoinable(finished task, or detach), cout get_id()
    will get the output:
    : thread::id of a non-executing thread
    *So, you can only call get_id() before join() or detach().*
    If a thread has finished its task, its id might be assigned to
    other thread.
    : std::this_thread::get_id()
    
* note
** two situations may lead to one thread occupying cpu
  - std::future_status::deferred
    #+BEGIN_SRC CPP
    // need to judge, otherwise, the while loop may run forever!
    // or use std::launch::async when constructing 
    // if (f.wait_for(std::chrono::seconds(0)) != std::futrue_status::deferred))
    while (f.wait_for(std::chrono::seconds(0)) != std::future_status::ready) {
      // wait
    }
    #+END_SRC
  - yield
    hint to reschedule to the next thread
** lifetime
   - when parsing reference to thread, make sure the object's lifetime
   is larger than the thread
   - detach thread will go on runing even main exit? Make sure
     global/static object not destruct if they are use in detached thread.
   
  
