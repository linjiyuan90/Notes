
* compile
  need to add
  : -lpthread
  when compile.

* concept
  join
  detach

* pthread
** pthread_cancel
   defer it until it reaches a cancellation point. \\
   cause dead lock/memory leak if cancel unsafely!
   
   : pthread_testcancel()
   : boost::this_thread::interruption_point()
   
polling ?

* boost
  use exception
  it'll call destructor automatically

* async & future
  #+BEGIN_SRC C++
  #include "future"
  int func();
  // try start func() asynchronously in the background (now or later or never)
  // assign the result to the object of class std::future
  std::future<int> result(std::async(func());
  // ^ auto works as well
  // do something else
  result.get();
  #+END_SRC
  use future for two reasons:
  - it allows access to the "future" outcome *(store state/result)* of
    the functionality passed to async(). The outcome might be either a
    return value or an exception.
    : std::future<void> for returns nothing
  - async() may not start ever (if no more separated thread is
    availble, it will defer), use future to force a start.

  To have better effect, maximize the distance between calling
  async() and calling get()
  
** launch policy
   To force async() to not defer the passed functionality, explicitly
   passing a /launch policy/.
   #+BEGIN_SRC C++
   // force func() to start asynchronously now or throw std::system_error
   // if it's not possible to call here
   std::future<long> result = std::async(std::launch::async, func);
   // std::launch::defered
   #+END_SRC
   In this case, no need to call get() anymore. If the *lifetime* of
   the returned future ends, the program will *wait* for func() to
   finish.

** deal with exceptions
   If exception is not caught in the thread, future will keep this
   state until get() is called, and propagated to main.

** waiting and polling
   You can can *only call get() once*. After get(), the future is in an
   invalid state, which can be checke only by calling valid() for the
   future.

   Below are callable more than once
*** wait()
    wait() forces the start of a thread a future represents and *waits*
    (block) for the termination.
    Looks like get(), but can be called more than once, and don't
    return result. Call get() after wait().
*** wait_for(), wait_until()
    do /not/ force the thread to get started if it hasn't started yet.
    #+BEGIN_SRC CPP
    std::future<...> f(std::async(func));
    ...
    f.wait_for(std::chrono::seconds(10));
    f.wait_until(std::system_clock()::now() + std::chrono::minutes(1));
    #+END_SRC
    wait_for, wait_until return one of the following:
    | std::future_status::deferred | if async() deferred the operation and no calls to wait() or get() have yet forced it to start(both function return immediately in this case) |
    | std::future_status::timeout  | the waiting expired due to the passing timeout                                                                                               |
    | std::future_status::ready    | the operation is finished                                                                                                                    |
    
** shared future
   future's get() can only be called once. With situation when
   multiple threads process the outcome, use shared_future. Here,
   multiple get() calls are possible and *yield the same result or
   throw the same exception*.
   : std::shared_future<int> f = std::async(func);
   : auto f = std::async(func).share();
   | future                   | shared_future                    |
   |--------------------------+----------------------------------|
   | T future<T>::get()       | const T& shared_future<T>::get() |
   | T& future<T&>::get()     | T& shared_future<T&>::get()      |
   | void future<void>::get() | void shared_future<void>::get()  |
   "The *single-use* value get() is *move optimized*, the *const reference*
   get() is *access optimized*."
   The multiple shared future objects share the same /shared
   state/. Though possible, it's risky to share one future object (by
   reference).

* thread
  As for async(), you can pass anything that's a /callable object/
  (function, member function, function object, lambda) together with
  possible additional arguments. It's recommended to pass all objects
  by value so that the thread uses only /local copies/.

  Thread is low-level interface, things it does not provides compared
  to async():
  - doesn't have a launch policy. Thread *always tries to start* the
    passed functionality in a new thread. If it isn't possible, it
    throws a std::system_error with the error code
    resource_unavailble_try_again.
  - *no interfaces to process the result or outcome of the thread*. The
    only thing you can get is a unique thread ID.
  - if an exception occurs that is not caught inside the thread, the
    program immediately aborts, calling std::terminate(). (won't
    propagate the exception to the caller?) \\
    : exception_ptrs ?
  - need to call join()(wait for teh end), detach()(let it run in the
    background without any control). If you don't do this before the
    lifetime of the thread objects ends or a move assignment to it
    happens, the program aborts, calling std::terminate()
  - if you let the thread run in the background and main() ends (return
    or exit), all threads are terminated abruptly.
    #+BEGIN_QUOTE
    To allow other threads to continue execution, the main thread
    should terminate by calling pthread_exit() rather than exit(3).
    #+END_QUOTE

    #+BEGIN_SRC C++
    #+END_SRC

** Thread IDs
   - Thread id of a joinable thread (thread with associated task) are
     unique. For those without associated task, its id is same as
     std::thread::id() (unique as well).
     : std::thread t;
     : assert(t.get_id() == std::thread::id());
     : std::this_thread::get_id()
   - Note! For those nojoinable(finished task, or detach), cout
     get_id() will get the output:
     : thread::id of a non-executing thread
     *So, you can only call get_id() before join() or detach().*
   - If a thread has finished its task, its id might be assigned to
     other thread.
   - the only way to identify a thread, such as a master thread, is
     to compare it to its saved ID when it was started
   - if a thread object is joinable, no other thread object can be
     assigned to it

** beware of detached threads
   - make sure that a detached thread does not access any object s
      after their lifetime has ended. Passing arguments by value is
      strongly recommended.
   - if a detached thread use a global/static object, do:
     * ensure these global/static objects are not destroyed before
       all detached threads finished accessing them. One approach to
       ensure is to use *condition variables* which the detached
       threads use to signal that they have finished.
     * end the program by calling quick_exit(), which won't call the
       destructors for global and static objects.
     * std::cin/cout/cerr and the other *global stream objects*
       according to the standard "are not destroyed during program
       execution," access to these objects in detached threads
       should introduce no undefined behavior.
* promise
   To retrieve result from thread, you can pass return arguments by
   reference. Another general mechanism is provided to pass result
   values and exceptions as *outcomes of a thread*: class
   std::promise. A promise object is the counterpart of a /future/
   object. Both are able to temporarily hold a /shared state/,
   representing a (result) value or an exception. While the future
   object allows you to *retrieve the data* (using get()), the promise
   object enables you to *provide the data* (by using set...()).
   - The promise *internally creates a /shared state/*, which can be
     used to store a value of the corresponding type or an exception,
     and can be used in a future object to retrieve this data as the
     outcome of the thread.
   - copying is not possible for promise, use std::ref()
   - catch exception in thread and set it to promise. Then this
     exception won't throw right now, can be catched later when future
     object call get(). Nice!
   - once set_value/exception, the /shared state/ is /ready/, and
     get() will return. There are set_value_at_thread_exit(val),
     set_exception_at_thread_exit(e), which make the /state ready/ at
     the end of the current thread (or throws std::future_error).
   - you can call get_future() only once. A second call throws a
     std::future:error with error code std::future_errc::future_already_retrieved.
   - if no /shared state/ is associated, a std::future_error with the
     error code std::future_errc::no_state might be thrown.
   - Can an a promise shared by several thread? It seems impossible
     since get_future can only be called once!

   | operation                         | effect                                                                                                   |
   |-----------------------------------+----------------------------------------------------------------------------------------------------------|
   | promise p                         |                                                                                                          |
   | promise p(rv)                     | move constructor; gets the state of /rv/ and removes the /shared state/ from rv                          |
   | p = rv                            | move assignment; if p is not /ready/, stores a std::future_error exception with condition broken_promise |
   | p.get_future()                    | yields a future object to retrieve the shared state (outcome of a thread)                                |
   | p.set_value(val)                  | set val as (return) value and makes the state /ready/ (or throws std::future_error)                      |
   | p.set_value_at_thread_exit(val)   |                                                                                                          |
   | p.set_exception(e)                |                                                                                                          |
   | p.set_exception_at_thread_exit(e) |                                                                                                          |

* packaged_task
  reset()

* note
** two situations may lead to one thread occupying cpu
  - std::future_status::deferred
    #+BEGIN_SRC CPP
    // need to judge, otherwise, the while loop may run forever!
    // or use std::launch::async when constructing 
    // if (f.wait_for(std::chrono::seconds(0)) != std::futrue_status::deferred))
    while (f.wait_for(std::chrono::seconds(0)) != std::future_status::ready) {
      // wait
    }
    #+END_SRC
  - std::this_thread::yield() \\
    hint to reschedule to the next thread, give up its time 
** lifetime
   - when parsing reference to thread, make sure the object's lifetime
     is larger than the thread
   - detach thread will go on runing even main exit? Make sure
     global/static object not destruct if they are use in detached thread.
   
  
** sth
   - while async, promise, packaged_task use /shared state/, thread can
     use /shared variales/, and thread use exception_ptr to process
     exception.

** summary
   - with the low-level interface of class thread, we can start a
     thread. To return data, we need shared variables (global or
     static or passed as argument). To return exceptions, we could
     use the type std::exception_ptr, which is returned by
     std::current_exception() and can be processed by
     std::rethrow_exception()
   - the concept of a /shared state/ allow us to deal with return
     values or exceptions in a more convenient way. With the
     low-level interface of a promise, we can create such a /shared
     state/, which we can process by using a future
   - at a higher level, with class packaged_task or async(), the
     /shared state/ automatically created and set with a return
     statement or an uncaught exception.
   - with packaged_task, we can create an object with a shared state
     where *we explicitly have to program when to start the thread*.
   - with std::async(), we *don't have to care when the thread exactly
     gets started*. The only thing we know is that we have to call
     get() when we need the outcome.

